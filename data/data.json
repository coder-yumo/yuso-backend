{
  "records": [
    {
      "id": "1746066250653507586",
      "title": "不良网站",
      "description": "只传播不良内容的网站（bushi）",
      "content": "言归正传，第一次交作业，改编自伙伴匹配系统，由根据标签匹配用户改编为根据标签匹配角色。作为不良人老粉，当第一次看到伙伴匹配系统时，就想着做一个不良人角色相关的网站，看过不良人的都知道，不良人或许真的可以称得上是国漫巅峰（不喜勿喷），里面的角色也是各具特色，别有一番风味。那么，不良网站主要就是提供了一个平台，用户可以创建自己喜欢的角色，公开显示到网站，所有人都可以看到网站上的所有角色。另外，如果你对不良人中的某一个组织或者地域或者人物关系感兴趣，你可以创建一个队伍，与你兴趣相投的用户可以加入到队伍，你们可以在队伍中展开讨论（目前聊天功能尚未开放，处于开发阶段）。\n好了，以上差不多就是网站的简单介绍了，欢迎感兴趣的朋友访问哦。\n\n网站链接：https://badboy-frontend-88532-7-1323701492.sh.run.tcloudbase.com\n\n当然，在开发网站过程中，也学到了很多东西。每当遇到一个全新的知识点时，我都会记录下来，等到空闲时间再吃透，同样做好记录，方便之后查阅。详情可参考（由于网站处于开发阶段，一些知识尚未解决，只是做了问题记录）：https://www.yuque.com/buguyiqiexiangqianchong/tw24ry/mzpbk6oasiegrp2u#DlURY\n\n附上页面预览图：\n\n![微信图片_20240113134426.png](https://pic.code-nav.cn/post_picture/1738514574744772610/c8DHGjyu-微信图片_20240113134426.png)\n\n![微信图片_20240113134458.png](https://pic.code-nav.cn/post_picture/1738514574744772610/lhPWPm44-微信图片_20240113134458.png)\n\n![微信图片_20240113134528.png](https://pic.code-nav.cn/post_picture/1738514574744772610/g5HVfaCt-微信图片_20240113134528.png)\n\n![微信图片_20240113134627.png](https://pic.code-nav.cn/post_picture/1738514574744772610/bEtGf6Sq-微信图片_20240113134627.png)\n\n\n",
      "category": "文章",
      "cover": "https://pic.code-nav.cn/post_cover/1738514574744772610/lRwU12zi-R-C.jpg",
      "language": null,
      "viewNum": 8,
      "thumbNum": 1,
      "favourNum": 0,
      "commentNum": 1,
      "priority": 0,
      "userId": "1738514574744772610",
      "reviewStatus": 1,
      "reviewMessage": null,
      "reviewerId": null,
      "reviewTime": null,
      "createTime": "2024-01-13T07:06:49.000+00:00",
      "updateTime": "2024-01-13T12:43:57.000+00:00",
      "user": {
        "id": "1738514574744772610",
        "planetCode": "21187",
        "userName": "badboy",
        "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEIYu0BicvLby7wQBHuQtrB7KgYGa2jxcpM0DSxxB0YNClJCsHhrlwUZD3yIm0tS4VIazZv8B0DyvKVBbQj6MNUnEHk7mopy9u093vc1vPbC7QQ/132",
        "gender": null,
        "userProfile": null,
        "userRole": "vip",
        "interests": null,
        "place": null,
        "birthday": null,
        "school": null,
        "major": null,
        "education": null,
        "graduationYear": null,
        "jobStatus": null,
        "company": null,
        "job": null,
        "workYear": null,
        "direction": null,
        "goal": null,
        "github": null,
        "blog": null,
        "score": 0,
        "coin": 0,
        "followeeNum": 0,
        "followNum": 0,
        "followStatus": null,
        "vipExpireTime": "2024-09-26T07:26:47.000+00:00",
        "lastLoginTime": null,
        "createTime": "2023-12-23T10:59:09.000+00:00",
        "updateTime": "2024-01-11T09:21:20.000+00:00"
      },
      "tags": [
        "文章",
        "Java",
        "后端"
      ],
      "fileList": null,
      "videoList": null,
      "atUserList": null,
      "pictureList": null,
      "hasThumb": false,
      "hasFavour": false,
      "needVip": null,
      "atUserVOList": null
    },
    {
      "id": "1745767317930778626",
      "title": "用我这套模板，几分钟做出文档网站！",
      "description": null,
      "content": "大家好，我是保姆皮，最近我上线了自己的《编程宝典》网站，可以在线阅读我分享过的各种编程学习路线和知识干货。\n\n> 指路：https://codefather.cn/\n\n![](https://pic.yupi.icu/1/image-20231207103516335.png)\n\n不少小伙伴催我出教程，说也想做个类似的文档网站。\n\n所以我用最快的速度出了 “保姆级文档网站制作教程”，并且开源了一套网站模板。大家只需要几分钟的时间，就能快速做出同款的、精简的文档网站。\n\n推荐观看视频教程：https://www.bilibili.com/video/BV1LQ4y1V79r/\n\n以下为文字版教程：\n\n\n\n## 引言\n\n首先，很多同学肯定会觉得这个网站的风格比较眼熟。没错，这是基于 VuePress 静态网站生成器开发的。\n\n有同学问了，你咋不用 vitepress 嘞？\n\n啊，也用过，但是在生态和成熟度上不及 VuePress，折腾一番后还是选择返璞归真。\n\n别看这么一个网站非常精简，但是想做好它，这里面的门道可多着呢。你要阅读 VuePress 的官方文档，还要在琳琅满目的插件中做选择，很费时间。\n\n我出这期教程的目的，就是帮大家做做减法，不用阅读那老长的官方文档，我帮大家选好了插件。甚至，我给大家提供了一套我们自己增强的、开箱即用的文档网站模板。\n\n以后你要做自己的文档网站，直接用这个模板，不用写代码，有手就行。\n\n\n\n## VuePress 文档网站制作教程\n\n### 一、项目启动\n\n先花 30 秒的时间启动项目。\n\n首先打开我的开源项目 codefather，切换分支为 `template` 模板。\n\n> 指路：https://github.com/liyupi/codefather\n\n![](https://pic.yupi.icu/1/1701828341298-db31f118-d2c2-4bd0-ac5b-c266b59220ce.png)\n\n然后下载代码压缩包：\n\n![](https://pic.yupi.icu/1/1701828425697-03c94a85-7238-4360-b1a8-ebc5642bbbf2.png)\n\n\n\n解压后，用 WebStorm 或 VS Code 等开发工具打开项目。\n\n项目基于 VuePress 实现，需要 Node 和 Npm 环境，尽量和我的版本号保持一致防止后面出现莫名其妙的报错，没有的同学请到官网安装一下。\n\n![](https://pic.yupi.icu/1/1701828667354-1e704075-bb03-4ede-b1d5-2189bd908e54.png)\n\n\n\n首次运行前，需要运行 `npm install` 命令安装依赖：\n\n![](https://pic.yupi.icu/1/1701828742475-2114b1aa-a9df-4f75-a4bc-f8079c792bf2.png)\n\n\n\n安装依赖成功后，在 `package.json` 文件中点击 `docs:dev` 运行即可：\n\n![](https://pic.yupi.icu/1/1701828797321-bd4e0815-e9f3-4dd9-a4c7-a4de923915f3.png)\n\n\n\n运行成功，默认在本地的 8080 端口，就能访问到网站啦！\n\n![](https://pic.yupi.icu/1/1701829057165-caec05a2-684f-4b12-9375-bf0fc532d417.png)\n\n\n\n接下来，我会详细讲解这套 VuePress 模板，包括目录结构、基本配置、主题配置、插件配置等，让大家在学会 VuePress 的基础上、能灵活运用这套模板轻松定制网站。\n\n\n\n### 二、模板目录结构\n\n先来看下 VuePress 模板的目录结构，如下图：\n\n![](https://pic.yupi.icu/1/1701829618648-2f58ea87-d472-459f-9bef-889602b11483.png)\n\n\n\n所有的文档（目录）直接放到项目根目录下即可。\n\n\n\n### 三、基本配置\n\n我们打开 VuePress 的核心配置文件 `config.ts`，所有的配置基本都集中在这个文件，可以在这里全局改变网站的内容、主题样式、使用插件增强能力等。\n\n\n\n先来看一些基本配置：\n\n\n\n#### 1、网站基本信息\n\n包括网站标题、描述，还有我们自定义的作者、域名、全局标签：\n\n```javascript\nconst author = \"程序员鱼皮\";\nconst domain = \"https://codefather.cn\";\nconst tags = [\"程序员\", \"编程\", \"计算机\"];\n\nexport default defineConfig({\n  title: \"鱼皮的编程宝典\",\n  description: \"贴心的编程学习路线，全面的编程知识百科\",\n  ...\n});\n```\n\n\n\n#### 2、网站 head 标签\n\nhead 标签作为 HTML 网页文件的大脑，通常包含了网页的重要基本信息，比如上面提到的网页标题、描述等。\n\n使用 VuePress 工具，我们可以在 head 配置中添加网站 head 标签信息，比如设置站点图标、设置有利于 SEO（搜索引擎优化）的元信息、添加第三方统计分析代码等：\n\n```javascript\nhead: [\n  // 站点图标\n  [\"link\", { rel: \"icon\", href: \"/favicon.ico\" }],\n  // SEO\n  [\n    \"meta\",\n    {\n      name: \"keywords\",\n      content:\n        \"程序员鱼皮, 编程学习路线, 编程知识百科, Java, 编程导航, 前端, 开发, 编程分享, 项目, IT, 求职, 面经\",\n    },\n  ],\n  // 百度统计\n  [\n    \"script\",\n    {},\n    `\n      var _hmt = _hmt || [];\n      (function() {\n        var hm = document.createElement(\"script\");\n        hm.src = \"https://hm.baidu.com/hm.js?2675818a983a3131404cee835018f016\";\n        var s = document.getElementsByTagName(\"script\")[0]; \n        s.parentNode.insertBefore(hm, s);\n      })();\n    `,\n  ],\n],\n```\n\n\n\n#### 3、永久链接\n\n默认情况下，VuePress 是根据文档层级生成的访问链接，如下图：\n\n![](https://pic.yupi.icu/1/1701830771997-fbcea109-8c66-4286-989e-f46f6da7d82a.png)\n\n\n\n但如果文档存放的目录改变了，那么原有的链接就会失效，会影响 SEO 和用户访问。\n\n所以建议使用永久链接，只要在 `config.ts` 中加上这行配置即可：\n\n```javascript\npermalink: \"/:slug\",\n```\n\n\n\n开启永久链接后，系统自动根据文章标题生成链接地址，会更简短、精确，不会被文档目录结构影响。\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1701830847837-543aed3e-1da3-4439-a269-ba4f977feb8a.png)\n\n\n\n永久链接的生成规则可以自己配置，或者给某个页面定制永久链接，详见官方文档。\n\n> 官方文档：[https://vuepress.vuejs.org/zh/guide/permalinks.html#%E8%83%8C%E6%99%AF](https://vuepress.vuejs.org/zh/guide/permalinks.html#背景)\n\n\n\n#### 4、开启文件热更新\n\nVuePress 默认提供了热更新，改动文档或配置时会自动更新网站，但是范围有限，如果是自定义的 js、ts 等前端文件，修改后不会触发热更新。\n\n可以添加 `extraWatchFiles` 配置解决，为特定范围的文件开启热更新。\n\n比如模板中所有的 ts 文件和侧边栏配置文件：\n\n```javascript\n// 监听文件变化，热更新\nextraWatchFiles: [\".vuepress/*.ts\", \".vuepress/sidebars/*.ts\"],\n```\n\n\n\n#### 5、Markdown 配置\n\nVuePress 的基本功能就是把我们写的 Markdown 文件渲染成网站，我们可以在 `markdown` 配置中自定义网站的渲染规则，比如显示代码块的行号、支持更细层级的标题渲染等：\n\n```javascript\nmarkdown: {\n  // 开启代码块的行号\n  lineNumbers: true,\n  // 支持 4 级以上的标题渲染\n  extractHeaders: [\"h2\", \"h3\", \"h4\", \"h5\", \"h6\"],\n},\n```\n\n\n\n### 四、主题配置\n\n这里我使用的是 VuePress 默认主题，因为更精简、更稳定。\n\n> 官网默认主题配置：https://vuepress.vuejs.org/zh/theme/default-theme-config.html\n\n\n\n也有同学推荐 Hope 主题，其实我以前有的文档网站就是用的它，但后面觉得界面有点复杂了，个人还是喜欢最精简的哈哈。\n\n想修改主题配置，只需要更改 `config.ts` 配置文件中的 `themeConfig` 配置即可。\n\n```javascript\nexport default defineConfig({\n\t...\n    \n  // 主题配置\n  themeConfig: {\n    logo: \"/logo.png\",\n    nav: navbar,\n    sidebar,\n    lastUpdated: \"最近更新\",\n\n    // GitHub 仓库位置\n    repo: \"liyupi/codefather\",\n    docsBranch: \"master\",\n\n    // 编辑链接\n    editLinks: true,\n    editLinkText: \"完善页面\",\n\n    // @ts-ignore\n    // 底部版权信息\n    footer,\n    // 额外右侧边栏\n    extraSideBar,\n  },\n});\n```\n\n\n\n#### 1、主题基本配置\n\n包括整个网站的 Logo、GitHub 仓库的基本信息、页面底部展示最近更新时间、页面底部展示编辑文章链接等。\n\n配置如下：\n\n```javascript\nexport default defineConfig({\n\t...\n    \n  // 主题配置\n  themeConfig: {\n    // 替换 logo\n    logo: \"/logo.png\",\n      \n    // 页面底部展示最近更新时间\n    lastUpdated: \"最近更新\",\n      \n    // GitHub 仓库和分支信息\n    repo: \"liyupi/codefather\",\n    docsBranch: \"master\",\n      \n    // 页面底部展示编辑文章\n    editLinks: true,\n    editLinkText: \"完善页面\",\n  },\n});\n```\n\n\n\n#### 2、导航栏配置\n\n由于导航栏配置可能比较复杂，为了让配置更清晰，我们可以集中把导航配置写在 `navbar.ts` 文件中。\n\n如下图：\n\n![](https://pic.yupi.icu/1/1701831963654-4bcf32d3-e36f-4abd-bdc7-24adad7a621d.png)\n\n\n\n然后在 `config.ts` 的主题配置中引用 `navbar` 即可：\n\n```javascript\nimport navbar from \"./navbar\";\n\nexport default defineConfig({\n  // 主题配置\n  themeConfig: {\n    nav: navbar,\n  },\n});\n```\n\n\n\n可以参考官方文档的语法，添加导航栏配置，支持子导航栏。\n\n导航栏配置文档：[https://vuepress.vuejs.org/zh/theme/default-theme-config.html#%E5%AF%BC%E8%88%AA%E6%A0%8F](https://vuepress.vuejs.org/zh/theme/default-theme-config.html#导航栏)\n\n\n\n示例代码：\n\n```javascript\n// .vuepress/config.js\nmodule.exports = {\n  themeConfig: {\n    nav: [\n      {\n        text: 'Languages',\n        ariaLabel: 'Language Menu',\n        items: [\n          { text: 'Chinese', link: '/language/chinese/' },\n          { text: 'Japanese', link: '/language/japanese/' }\n        ]\n      }\n    ]\n  }\n}\n```\n\n\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1701832229220-1a5f0c33-463e-4230-b2d7-62a39f9f1ff6.png)\n\n\n\n#### 3、侧边栏配置\n\n和导航栏一样，所有的侧边栏配置都放在 `sidebar.ts` 文件中，然后在 `config.ts` 中引用。\n\n但是由于侧边栏的配置比较复杂，文章多的时候需要分组、还要能自动识别文章中的小标题，所以这里我摸索出来的 **最佳实践** 是：\n\n1）将同类的文章放到同一个目录里，比如学习路线：\n\n![](https://pic.yupi.icu/1/1701832408501-84b15aeb-53c6-4c36-9e06-46016ff8fec9.png)\n\n\n\n2）将该目录的所有文章（侧边栏配置）集中写在单独的配置文件中，比如 `roadmapSideBar.ts`，放到 `sidebars` 目录下：\n\n![](https://pic.yupi.icu/1/1701832499136-0c9187f4-8da0-467f-8744-b9819e82899f.png)\n\n\n\n3）在侧边栏 `sidebar.ts` 配置中，引用各分类的侧边栏配置文件，实现不同分类下的文章，展示的侧边栏不同。\n\n```typescript\nimport {SidebarConfig4Multiple} from \"vuepress/config\";\n\nimport roadmapSideBar from \"./sidebars/roadmapSideBar\";\n// @ts-ignore\nexport default {\n    \"/学习路线/\": roadmapSideBar,\n    // 降级，默认根据文章标题渲染侧边栏\n    \"/\": \"auto\",\n} as SidebarConfig4Multiple;\n```\n\n\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1697943889535-32cede40-9378-4b06-97c1-bc5648045f18.png)\n\n\n\n#### 4、底部配置\n\n这是我们自己使用 VuePress 自定义主题能力二次开发的功能，和导航栏、侧边栏配置一样，只用在 `footer.ts` 中填写配置，就能自动在网页底部生成友情链接、备案信息等，非常方便！\n示例代码如下：\n\n```javascript\n/**\n * 底部版权信息\n */\nexport default {\n  friendLinks: [\n    {\n      label: \"鱼鸢网络\",\n      href: \"https://yuyuanweb.com/\",\n    },\n    {\n      label: \"老鱼简历\",\n      href: \"https://www.laoyujianli.com/\",\n    },\n    {\n      label: \"编程学习圈\",\n      href: \"https://yupi.icu\",\n    },\n  ],\n  copyright: {\n    href: \"https://beian.miit.gov.cn/\",\n    name: \"沪ICP备19026706号-6\",\n  },\n};\n```\n\n\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1701832759044-127c6de2-e8d4-4349-aaf2-0d46cc582155.png)\n\n\n\n#### 5、右侧附加边栏配置\n\n这也是我们自己使用 VuePress 自定义主题能力二次开发的功能，和前面讲的配置一样，只用在 `extraSideBar.ts` 中填写配置，就能自动在网页右侧生成一个固定的侧边栏了，从而提供一些附加能力，比如对站长很重要的引流支持等。\n\n示例代码如下，支持自定义 HTML 代码：\n\n```javascript\n/**\n * 额外右侧边栏\n */\nexport default [\n  {\n    title: \"手机看\",\n    icon: \"/icon/mobile.png\",\n    popoverTitle: \"微信扫一扫\",\n    popoverUrl:\n      \"/qrcode-codefather.png\",\n    popoverDesc: \"可以手机看或分享至朋友圈\",\n  },\n  {\n    title: \"星球\",\n    icon: \"/icon/xingqiu.png\",\n    popoverTitle:\n      '<span style=\"font-size:0.8rem;font-weight:bold;\"><span style=\"color:red;\">保姆级实战项目教程</span>、编程学习指南、学习资源、求职指南、技术分享、编程交流</span>',\n    popoverUrl:\n      \"/qrcode-codenav.png\",\n    popoverDesc: \"知识星球：编程导航\",\n  },\n}\n```\n\n\n\n效果如下：\n\n![](https://pic.yupi.icu/1/1701832927041-a9724d03-33c2-4121-8ddd-6ff055f3a6d3.png)\n\n\n\n### 五、插件配置\n\n除了上述基本能力外，我选择 VuePress 的主要原因就是它的插件生态特别好，随便下个插件，就能增强网站的能力。\n\n可以在 awesome-vuepress 项目中看到大量的插件，点进去就能看到插件的介绍、安装方式等。\n\n>  指路：https://github.com/vuepressjs/awesome-vuepress#plugins\n\n\n\n![](https://pic.yupi.icu/1/1701833393252-b2fa2cce-34fb-4401-841e-40055ca48af0.png)\n\n\n\n但是大家也发现了，插件太多，反而不知道该用哪些了。。。一个个试也太费时间了！\n\n所以这里我帮大家做了减法，在模板中只保留了我认为有用的核心插件。\n\n分别介绍一下：\n\n\n\n#### 1、返回顶部\n\n安装（其实模板中已经帮大家装好了）：\n\n```bash\nyarn add -D @vuepress/plugin-back-to-top\n# OR npm install -D @vuepress/plugin-back-to-top\n```\n\n\n\n开启插件配置，一行代码就能搞定：\n\n```javascript\nmodule.exports = {\n  plugins: ['@vuepress/back-to-top']\n}\n```\n\n\n\n#### 2、图片点击放大\n\n可以让网站中的所有图片支持点击放大功能。\n\n开启插件配置，一行代码就能搞定：\n\n```javascript\nmodule.exports = {\n  plugins: [\"@vuepress/medium-zoom\"]\n}\n```\n\n\n\n#### 3、SEO 相关插件\n\n安装插件后，只需要修改几行配置，就能让你的网站更容易被搜索引擎收录，从而提高访问量。\n\nSEO 相关插件有很多，列举几个我觉得不错的：\n\n\n\n1）谷歌分析\n\n是一款有利于谷歌搜索引擎优化的插件：\n\n```javascript\nmodule.exports = {\n  plugins: [\n    [\n      '@vuepress/google-analytics',\n      {\n        'ga': '' // 补充自己的谷歌分析 ID，比如 UA-00000000-0\n      }\n    ]\n  ]\n}\n```\n\n\n\n2）vuepress-plugin-seo\n\n\n\n作用是可以自定义生成的网站 meta 标签内容，比如把文章描述、标签信息放到标签中，从而增加收录率。\n\n> 插件官方：https://github.com/lorisleiva/vuepress-plugin-seo\n\n\n\n示例代码：\n\n```javascript\n// 定义常量\nconst author = \"程序员鱼皮\";\nconst domain = \"https://codefather.cn\";\nconst tags = [\"程序员\", \"编程\", \"计算机\"];\n\n// https://github.com/lorisleiva/vuepress-plugin-seo\n[\n  \"seo\",\n  {\n    siteTitle: (_, $site) => $site.title,\n    title: ($page) => $page.title,\n    description: ($page) =>\n      $page.frontmatter.description || $page.description,\n    author: (_, $site) => $site.themeConfig.author || author,\n    tags: ($page) => $page.frontmatter.tags || tags,\n    type: ($page) => \"article\",\n    url: (_, $site, path) =>\n      ($site.themeConfig.domain || domain || \"\") + path,\n    image: ($page, $site) =>\n      $page.frontmatter.image &&\n      (($site.themeConfig.domain &&\n        !$page.frontmatter.image.startsWith(\"http\")) ||\n        \"\") + $page.frontmatter.image,\n    publishedAt: ($page) =>\n      $page.frontmatter.date && new Date($page.frontmatter.date),\n    modifiedAt: ($page) => $page.lastUpdated && new Date($page.lastUpdated),\n  },\n],\n```\n\n\n\n3）sitemap 插件\n\n可以自动给网站生成 `sitemap.xml` 站点地图，让搜索引擎更了解你的网站。\n\n> 插件官方：https://github.com/ekoeryanto/vuepress-plugin-sitemap\n\n\n\n配置代码如下：\n\n```javascript\n// https://github.com/ekoeryanto/vuepress-plugin-sitemap\n[\n  \"sitemap\",\n  {\n    hostname: domain,\n  },\n],\n```\n\n\n\n4）自动推送到百度插件\n\n除了被动等待搜索引擎收录文章外，我们也可以主动给搜索引擎推送文章，提高收录率。\n\n使用这个插件，文章就会定期、自动地推送给百度，非常方便。\n\n> 插件官方：https://github.com/IOriens/vuepress-plugin-baidu-autopush\n\n\n\n配置代码如下：\n\n```js\n// https://github.com/IOriens/vuepress-plugin-baidu-autopush\n[\n  'vuepress-plugin-baidu-autopush'\n]\n```\n\n\n\n#### 4、支持代码复制\n\n这个插件对程序员来说可太实用了，只需一行配置，用户就能一键复制网站上的代码块：\n\n![](https://pic.yupi.icu/1/1701834155760-4192014f-168f-4a8c-aa4a-d9315cac3c73.png)\n\n\n\n配置代码如下：\n\n```js\n// https://github.com/znicholasbrown/vuepress-plugin-code-copy\n[\n  \"vuepress-plugin-code-copy\",\n  {\n    successText: \"代码已复制\",\n  },\n],\n```\n\n\n\n#### 5、配置 RSS 订阅\n\nRSS 是一种统一的内容更新标准，使用这个插件，可以让更多用户通过 RSS 订阅的方式查看到你网站的内容，从而增加访问量。\n\n> 插件官方：https://github.com/webmasterish/vuepress-plugin-feed\n\n\n\n配置代码如下：\n\n```js\n// https://github.com/webmasterish/vuepress-plugin-feed\n[\n  \"feed\",\n  {\n    canonical_base: domain,\n    count: 10000,\n    // 需要自动推送的文档目录\n    posts_directories: [],\n  },\n],\n```\n\n\n\n#### 6、**显示文章标签插件**\n\n> 插件官方：https://github.com/zq99299/vuepress-plugin/tree/master/vuepress-plugin-tags\n\n\n\n这个插件其实可有可无，允许你用 Markdown 的 FrontMatter 语法定义标签，然后在网站上展示。\n\n比如在某篇文章开头定义了如下代码：\n\n![](https://pic.yupi.icu/1/1701834439173-809fcc5a-771d-4138-8238-574ff741bc87.png)\n\n\n\n一行代码就能开启配置了：\n\n```js\n// https://github.com/zq99299/vuepress-plugin/tree/master/vuepress-plugin-tags\n[\"vuepress-plugin-tags\"],\n```\n\n\n\n然后就能看到如下效果：\n\n![](https://pic.yupi.icu/1/1701834618561-8a005ce0-282a-4878-904c-8b740d5671c7.png)\n\n\n\n\n\n#### 7、图片懒加载\n\n插件官方：https://github.com/tolking/vuepress-plugin--lazy\n\n\n\n最后这个插件我觉得最有用，只需要一行代码配置：\n\n```js\n['-lazy']\n```\n\n\n\n就能给网站所有的图片添加懒加载功能，当页面滚动到图片位置时才会请求加载图片，对于图片较多的网站来说，大幅提高加载速度、节约带宽。\n\n\n\n\n\n### 六、项目部署\n\n最后，我们要进行项目部署，也就是发到服务器上供别人访问。\n\nVuePress 的部署非常简单，首先在 `package.json` 文件中执行 `docs:build` 打包命令：\n\n![](https://pic.yupi.icu/1/1701834863289-d27beba6-8038-47d7-b047-f41982cbe7cf.png)\n\n\n\n打包成功，可以看到 `.vuepress` 目录下多了个 `dist` 目录，所有生成的网页资源都在该目录下：\n\n![](https://pic.yupi.icu/1/1701834892931-d583c19b-f357-4309-a2f7-58f78e6e4e57.png)\n\n\n\n接下来，我们只需要把 `dist` 目录下所有的文件，扔到服务器上就可以了。我之前已经给大家分享了好几种不同的项目上线方式，感兴趣的同学可以翻翻我之前的视频，这里就不重复演示了。\n\n![](https://pic.yupi.icu/1/WX20231206-144059@2x.png)\n\n\n\n## 最后\n\n通过这个教程，我相信大家不仅学到了文档网站的制作方法，还收获了很多其他的前端小知识，比如 SEO、懒加载之类的，希望对大家有帮助，都能做出自己的文档网站来沉淀分享知识。\n\n学会的话点赞收藏支持下啦，谢谢大家~",
      "category": "文章",
      "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/dZmeree6-640 (5).png",
      "language": null,
      "viewNum": 19,
      "thumbNum": 0,
      "favourNum": 0,
      "commentNum": 0,
      "priority": 0,
      "userId": "1601072287388278786",
      "reviewStatus": 1,
      "reviewMessage": null,
      "reviewerId": null,
      "reviewTime": null,
      "createTime": "2024-01-12T11:18:58.000+00:00",
      "updateTime": "2024-01-13T12:44:43.000+00:00",
      "user": {
        "id": "1601072287388278786",
        "planetCode": "1",
        "userName": "程序员鱼皮",
        "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
        "gender": 1,
        "userProfile": "这个网站的老大",
        "userRole": "admin",
        "interests": [
          "C++",
          "Java",
          "Python",
          "算法"
        ],
        "place": "上海",
        "birthday": "1998-11-03",
        "school": "东华大学",
        "major": "网络工程",
        "education": null,
        "graduationYear": 2020,
        "jobStatus": null,
        "company": null,
        "job": null,
        "workYear": 2,
        "direction": "后端",
        "goal": null,
        "github": "https://github.com/liyupi",
        "blog": "https://yupi.icu",
        "score": 3020,
        "coin": 170,
        "followeeNum": 1331,
        "followNum": 6,
        "followStatus": null,
        "vipExpireTime": "2286-11-20T17:46:39.000+00:00",
        "lastLoginTime": null,
        "createTime": "2022-12-09T04:32:33.000+00:00",
        "updateTime": "2024-01-12T06:15:20.000+00:00"
      },
      "tags": [
        "文章"
      ],
      "fileList": null,
      "videoList": null,
      "atUserList": null,
      "pictureList": null,
      "hasThumb": false,
      "hasFavour": false,
      "needVip": null,
      "atUserVOList": null
    },
    {
      "id": "1745761482102022146",
      "title": "Springboot项目中快速引入Rabbit MQ通用做法",
      "description": "本篇是在做BI项目时尝试引入MQ来优化项目时发现，MQ引入到项目中做法比较类似。变的只是谁发消息给谁，谁去监听消息。至于MQ的可靠性（比如生产者可靠性、消费者可靠性、消息可靠性）都是通过固定参数进行配置。 因此将引入MQ到BI项目的过程抽象出来，变成通用的方法～",
      "content": "# ⭐由来\n\n本篇是在做BI项目时尝试引入MQ来优化项目时发现，MQ引入到项目中做法比较类似。变的只是谁发消息给谁，谁去监听消息。至于MQ的可靠性（比如生产者可靠性、消费者可靠性、消息可靠性）都是通过固定参数进行配置。<br />因此将引入MQ到BI项目的过程抽象出来，变成通用的方法～\n\n# 🔶引入MQ目的\n\n砍掉耗时久的业务，缩短单个业务时间，监听者异步执行耗时久任务<br />做完之后，你可以完成springboot项目中MQ基本配置，并且MQ具有一定可靠性~😀\n\n# ⭕步骤\n\n1. 在Application中配置MQ\n\t1. 生产者确认机制，重连机制、消费者能者多劳、确认机制、失败消息处理策略\n\t2. 保证可靠性（配备了生产者确认，重连、消费者能者多劳，确认机制，失败消息处理策略） \n\n_**注意：不清楚的建议学习后配置，不要直接复制，按需设置~**_\n\n```xml\nspring:\n\trabbitmq:\n\t  # 连接信息\n\t  host: xxx # 你的IP地址\n\t  port: 5672\n  \t# 用户相关信息建议在rabbitMQ中设置好\n\t  virtual-host: /bi # 可在UI界面创建独属项目的虚拟机与用户名\n\t  username: xxx # 用户名\n\t  password: xxx # 密码\n\t  connection-timeout: 200ms # max waited time\n\t\n\t  # 生产者（消息发送者）\n\t  # 生产者确认机制 - 默认取消，消耗性能\n\t  publisher-confirm-type: none\n\t  publisher-returns: false\n\t  template:\n\t    # 生产者重连机制\n\t    retry:\n\t      enabled: true\n\t      initial-interval: 1000ms\n\t      multiplier: 1\n\t      max-attempts: 3\n\t\n\t  # 消费者（监听者）\n\t  listener:\n\t    simple:\n\t      prefetch: 1 # （能者多劳）每次只能获取一条信息，处理完才能获取下一条\n\t      acknowledge-mode: auto # 消费者确认 - 自动模式\n\t      retry:\n\t        enabled: true # 失败消息处理策略\n```\n\n```java\n/**\n * 失败者消息处理策略实现\n */\n@Bean\npublic MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate){\n    return new RepublishMessageRecoverer(rabbitTemplate, BI_ERROR_EXCHANGE, BI_ERROR_ROUTING_KEY);\n}\n```\n\n2. 统一确定并定义业务的有关MQ常量 `MQConstant.java`\n\t1. 交换机、队列、Key\n\t2. error交换机，队列，Key（_按需设置_）\n3. 开始初始化\n\t1. 业务MQ 与 error交换机MQ，并绑定关系（选一个就行，推荐第二种）\n\n```java\n@Configuration\npublic class ErrorConfiguration {\n\n    @Bean\n    public Queue errorQueue() {\n        return QueueBuilder.durable(BI_ERROR_QUEUE).build();\n    }\n\n    @Bean\n    public DirectExchange errorExchange() {\n        return ExchangeBuilder.directExchange(BI_ERROR_EXCHANGE).build();\n    }\n\n    @Bean\n    public Binding errorBinding() {\n        return BindingBuilder.bind(errorQueue()).to(errorExchange()).with(BI_ERROR_ROUTING_KEY);\n    }\n\n}\n```\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n        // 队列：\n        // name - 队列名字\n        // durable - 队列持久化，不会随着MQ关闭而消失\n        // arguments：使队列为Lazy queue将消息尽快写入磁盘\n        value = @Queue(\n                name = BI_QUEUE_NAME,\n                durable = \"true\",\n                arguments = @Argument(name = \"x-queue-mode\", value = \"lazy\")),\n        // 交换机:指定交换机的名字与类型(默认direct)\n        exchange = @Exchange(name = BI_EXCHANGE_NAME, type = ExchangeTypes.DIRECT),\n        // 按交换机类型(Direct、Topic),设置Key\n        key = BI_ROUTING_KEY\n))\npublic void receiveMessage(String msg) {\n```\n\n\n      2. JSON消息转换器（替换掉原生的JDK）\n\n\n```java\n/**\n * 消息转换器\n * @return\n */\n@Bean\npublic MessageConverter messageConverter(){\n    return new Jackson2JsonMessageConverter();\n}\n```\n\n3. 编写业务代码（根据实际业务）\n\t1. 发送信息：砍掉耗时久的业务，变成发送消息\n\t\t1. 选用唯一性的信息，如id\n\t\t2. 确定好消息的数据类型\n\t2. 监听信息：添加监听者，执行耗时久的业务。\n\t\t1. 需要根据实际情况修改代码\n\t\t2. 可以根据业务实际情况使：**业务幂等性**\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n        // 队列：\n        // name - 队列名字\n        // durable - 队列持久化，不会随着MQ关闭而消失\n        // arguments：使队列为Lazy queue将消息尽快写入磁盘\n        value = @Queue(\n                name = BI_QUEUE_NAME,\n                durable = \"true\",\n                arguments = @Argument(name = \"x-queue-mode\", value = \"lazy\")),\n        // 交换机:指定交换机的名字与类型(默认direct)\n        exchange = @Exchange(name = BI_EXCHANGE_NAME, type = ExchangeTypes.DIRECT),\n        // 按交换机类型(Direct、Topic),设置Key\n        key = BI_ROUTING_KEY\n))\npublic void receiveMessage(Long chatId) {\n    // 0. 业务幂等性判断 - 基于乐观锁改造\n    boolean update = chartService.lambdaUpdate()\n            .set(Chart::getStatus, RUNNING_STATUS)\n            .eq(Chart::getId, chatId)\n            .eq(Chart::getStatus, WAIT_STATUS)\n            .update();\n    if (!update) {\n        handleChartUpdateError(chatId, \"该图表正在生成中！请耐心等待\");\n        return;\n    }\n```\n\n当然，还可以对其进行拓展，比如对error队列进行监听，针对错误消息进行特殊业务处理等等~<br />至此之后，MQ基本操作以及配置完毕~并且MQ可靠性相对高。\n\n最后，希望对你有用~",
      "category": "文章",
      "cover": null,
      "language": null,
      "viewNum": 3,
      "thumbNum": 0,
      "favourNum": 0,
      "commentNum": 0,
      "priority": 0,
      "userId": "1627854772813975553",
      "reviewStatus": 1,
      "reviewMessage": null,
      "reviewerId": null,
      "reviewTime": null,
      "createTime": "2024-01-12T10:55:46.000+00:00",
      "updateTime": "2024-01-13T07:08:59.000+00:00",
      "user": {
        "id": "1627854772813975553",
        "planetCode": "18055",
        "userName": "小何同学",
        "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/pSUPib7O88l3Xe43fThm8miaKzCRRjc1bkNzHQbTCAWgQEIL9ORdaFw2rp9d3mTxyHGoKR2Ex1QiaVUia4sZhel4ZQ/132",
        "gender": null,
        "userProfile": null,
        "userRole": "vip",
        "interests": null,
        "place": null,
        "birthday": null,
        "school": null,
        "major": null,
        "education": null,
        "graduationYear": null,
        "jobStatus": null,
        "company": null,
        "job": null,
        "workYear": null,
        "direction": null,
        "goal": null,
        "github": null,
        "blog": null,
        "score": 0,
        "coin": 0,
        "followeeNum": 0,
        "followNum": 0,
        "followStatus": null,
        "vipExpireTime": "2025-02-17T10:47:58.000+00:00",
        "lastLoginTime": null,
        "createTime": "2023-02-21T02:16:36.000+00:00",
        "updateTime": "2024-01-12T10:53:08.000+00:00"
      },
      "tags": [
        "文章"
      ],
      "fileList": null,
      "videoList": null,
      "atUserList": null,
      "pictureList": null,
      "hasThumb": false,
      "hasFavour": false,
      "needVip": null,
      "atUserVOList": null
    },
    {
      "id": "1745075867219927042",
      "title": "一篇文章弄懂Lambda表达式",
      "description": null,
      "content": "# Lambda\n\n## Lambda简介\n\nLambda表达式是`Java8`引入的一个重要特性，相当于一个语法糖。\n\n> 语法糖（Syntactic sugar）是指在编程语言中引入的一种语法，它可以使代码更易读、更简洁，但并没有引入新的功能或改变语言的底层机制。语法糖并不会改变语言的语义，只是提供了一种更方便的编写方式。\n\n* Lambda表达式可以被视为**匿名函数**\n* 允许在**需要函数**的地方以**更简洁的方式定义功能**\n\n**使用条件：**只要是**函数式接口**就可以用Lambda表达式简化\n\n> 函数式接口：接口中有且只有一个未实现的方法，这个接口就叫函数式接口\n\n如果接口中有超过一个未实现方法，则不是函数式接口，不能用Lambda表达式\n如果接口中有一个未实现方法，有一个默认实现方法，则是函数式接口，可以用Lambda表达式\n\n如：\n\n```\n// 接口中有超过一个未实现方法,不是函数式接口\ninterface MyInterface {\n    int sum(int a, int b);\n    int min(int a, int b);\n}\n\n// 接口中只有一个未实现的方法,是函数式接口\ninterface MyCase{\n    int hello();\n    default int hello(int a){return a;} //默认实现\n}\n```\n\n可以用`jdk`中提供的检查注解`@FunctionalInterface`来检查该接口是否为函数式接口\n\n正常情况：\n\n<img src=\"https://img.pidanxia.ink/image/202401100036334.png\" alt=\"image-20240109160929223\" style=\"zoom:80%;\" />\n\n异常情况：<img src=\"https://img.pidanxia.ink/image/202401100036307.png\" alt=\"image-20240109160954618\" style=\"zoom:80%;\" />\n\n---\n\n\n\n## Lambda表达式与函数式接口\n\n举个例子：\n\n有一个接口`MyInterface`，里面有一个方法`sum()`。\n\n```\ninterface MyInterface {\n    int sum(int a, int b);\n}\n```\n\n如果想要实现这个接口，我们可以使用两种方法。\n\n1. 自己写实现类\n\n   ```\n   class MyInterfaceImpl implements MyInterface {\n       @Override\n       public int sum(int a, int b) {\n           return a + b;\n       }\n   }\n   ```\n\n   然后调用\n\n   ```\n   public class Lambda {\n       public static void main(String[] args) {\n           MyInterface myInterface = new MyInterfaceImpl();\n           int result = myInterface.sum(1, 2);\n           System.out.println(result);\n       }\n   }\n   ```\n\n2. 创建匿名实现类\n\n   如果每个接口都要写实现类的话，总觉得会有点麻烦。\n\n   而且，如果在以后的业务中，要实现的方法不是两数之和，而是两数的平方和的话，那我岂不是要再写一个实现类？\n\n   为了解决这个问题，我们可以采用[匿名实现类](https://pidanxia.ink/inner-class/)，**动态的**去实现接口。\n\n   ```\n   public class Lambda {\n       public static void main(String[] args) {\n   \n           // 1. 自己创建实现类对象\n           MyInterface myInterface = new MyInterfaceImpl();\n           int result = myInterface.sum(1, 2);\n           System.out.println(\"我是 自己创建的实现类对象 \" + result);\n   \n           // 2. 创建匿名实现类\n           MyInterface myInterface1 = new MyInterface() {\n               @Override\n               public int sum(int a, int b) {\n                   return a*a + b*b;\n               }\n           };\n           int result1 = myInterface1.sum(1, 2);\n           System.out.println(\"我是 匿名实现类 \" + result1);\n       }\n   }\n   ```\n\n   运行结果：![image-20240109115924448-1704792569563-1](https://img.pidanxia.ink/image/202401100037364.png)\n\n可以看到，每次创建匿名实现类的时候，有很多格式上的东西是每次都要写的，这样就很冗余。比如下面我选中的这部分：\n\n![image-20240109150517900-1704792569563-2](https://img.pidanxia.ink/image/202401100036273.png)\n\n这部分在上面的接口`interface MyInterface`中就已经定死了。就算不写`new MyInterface()`，从创建匿名实现类的前面部分**MyInterface** myInterface1，也可以看出实现的就是`MyInterface`接口。\n\n与前面相比，lambda表达式只保留动态的东西，把写死的东西去掉。\n用lambda表达式的方式实现接口：\n\n```\n        // 3. Lambda表达式实现接口  参数列表 + 箭头 + 方法体\n        MyInterface myInterface2 = (int a, int b) -> {\n            return a * a + b * b;\n        };\n```\n\n这是lambda表达式的完整写法，然而我们可以看到，入参的类型在接口中也是定好的。这就说明还有更**简化的写法**：\n\n1. 参数类型可以不写，只写参数名，参数变量名随意定义\n\n   ```\n           MyInterface myInterface3 = (x, y) -> {\n               return  x * x + y * y;\n           };\n   ```\n\n   参数名不一定是接口中定义的`(a,b)`，也可以定义为其他的名字，比如`(x,y)`\n\n2. 参数部分在没有入参的时候，最少可以只有一个`()`，**但是不能不写括号！！！！**\n\n   或者在只有一个入参的时候，只有一个参数名\n\n   ```\n   interface MyCase{\n       int hello();\n   }\n   \n   public class Lambda {\n       public static void main(String[] args) {\n           MyCase myCase = () -> {\n               return 1;\n           };\n       }\n   }\n   ---------------------------------------------------\n   interface MyCase1{\n       int hello(int a);\n   }\n   \n   public class Lambda {\n       public static void main(String[] args) {\n           MyCase1 myCase1 = a -> {\n               return a + 1;\n           };\n       }\n   }\n   ```\n\n3. 方法体只有一句话的时候，`{}`和`return`可以省略\n\n   ```\n   interface MyCase1{\n       int hello(int a);\n   }\n   \n   public class Lambda {\n       public static void main(String[] args) {\n           MyCase1 myCase11  = a ->  a + 2;\n           // 调用方法\n           System.out.println(myCase11.hello(1));\n       }\n   }\n   ```\n\n---\n\n\n\n## Lambda表达式使用\n\n未来使用函数时接口会比较频繁，当调用某个方法传入参数，这个参数实例是一个接口对象，且只定义了一个方法，就可以直接用Lambda简化写法\n\n### 比较器的使用\n\n当我们使用比较器的时候，可以使用Lambda表达式简化写法\n\n```\npublic class Lambda {\n    public static void main(String[] args) {\n        ArrayList<String> names = new ArrayList<String>();\n        names.add(\"Pidanxia\");\n        names.add(\"Lucy\");\n        names.add(\"Bob\");\n        names.add(\"Tom\");\n        \n        // 普通写法\n        Collections.sort(names,new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return o1.compareTo(o2);\n            }\n        });\n        \n        // Lambda写法\n        Collections.sort(names,(o1,o2)->o1.compareTo(o2));\n    }\n}\n```\n\n可以看到Lambda表达式与普通写法相比，简洁了非常多。\n除了Lambda表达式之外，还可以用方法引用来简化写法。如：\n\n`Collections.sort(names, String::compareTo);`\n\n> 类::方法：表示引用类中的实例方法。\n>\n> 比如例子中的语句，就是说，以`names`为入参，调用`String类`中的`compareTo`方法\n\n### 线程的使用\n\n```\n        // 普通写法\n        new Thread(){\n            @Override\n            public void run() {\n                System.out.println(\"Hello\");\n            }\n        }.start();\n        // Lambda写法\n        new Thread(()->System.out.println(\"Hello\")).start();\n```\n\n",
      "category": "文章",
      "cover": null,
      "language": null,
      "viewNum": 24,
      "thumbNum": 0,
      "favourNum": 1,
      "commentNum": 2,
      "priority": 0,
      "userId": "1674965546757525505",
      "reviewStatus": 1,
      "reviewMessage": null,
      "reviewerId": null,
      "reviewTime": null,
      "createTime": "2024-01-10T13:31:23.000+00:00",
      "updateTime": "2024-01-13T09:47:11.000+00:00",
      "user": {
        "id": "1674965546757525505",
        "planetCode": "23765",
        "userName": "无名",
        "userAvatar": null,
        "gender": null,
        "userProfile": null,
        "userRole": "vip",
        "interests": null,
        "place": null,
        "birthday": null,
        "school": null,
        "major": null,
        "education": null,
        "graduationYear": null,
        "jobStatus": null,
        "company": null,
        "job": null,
        "workYear": null,
        "direction": null,
        "goal": null,
        "github": null,
        "blog": null,
        "score": 0,
        "coin": 0,
        "followeeNum": 1,
        "followNum": 0,
        "followStatus": null,
        "vipExpireTime": "2024-06-17T10:42:34.000+00:00",
        "lastLoginTime": null,
        "createTime": "2023-07-01T02:18:00.000+00:00",
        "updateTime": "2023-12-06T08:58:35.000+00:00"
      },
      "tags": [
        "文章"
      ],
      "fileList": null,
      "videoList": null,
      "atUserList": null,
      "pictureList": null,
      "hasThumb": false,
      "hasFavour": false,
      "needVip": null,
      "atUserVOList": null
    },
    {
      "id": "1745052382141620226",
      "title": "从小公司到大厂，重点都考什么？",
      "description": null,
      "content": "大家好，我是鱼皮，今天 [编程导航](https://mp.weixin.qq.com/s/eNjauC-3361z-l7fy3VssA) 的鱼友问了我一个很不错的求职问题，大概是下面这样：\n\n> 我是一年工作经验小公司后端，我该怎样准备去向中大厂跳槽？\n\n\n\n想要知道如何准备跳槽到中大厂，我们就要了解小公司、中厂和大厂的求职考察重点。个人观点，仅供参考！\n\n一般来说，小公司最注重实践能力，即 **你能不能干活** ，关注求职者的 **下限** 。很多时候要求并不高，你能用开发框架写代码基本就行了。\n\n所以简历上有实际上线的项目经历是格外加分的，面试时也会重点考察你的项目经历。当然，凡事不绝对，也有老板不懂技术的小公司，就喜欢到网上找点八股文，然后像考试一样机械地考察你。\n\n中厂的要求会有所提高，不仅会注重实践能力，同时还会关注你的基础和可培养性。\n\n所以投递中厂，简历上不仅要有编程开发相关的技术栈，还要有算法数据结构、计算机网络等计算机基础相关的内容。中厂的面试一般来说会有算法题目、八股文的基本功考察，也会有项目经历的考察。\n\n想要进大厂，难度就直接指数级上升了。大厂除了注重实践能力、基本功之外，还会关注候选人的自主性和潜能，保证候选人未来能够推动事情的发展并应对种种挑战。不仅关注求职者的下限，更关注 **上限** 。\n\n而且因为大家都想进大厂、投简历又没成本，所以竞争十分激烈，这才有了笔试和学历的种种门槛。所以想进大厂，你要通过一切办法在简历上给自己贴金，各种竞赛奖项、实习科研经历、各种光环等等，都能快速证明你的能力和自主性，让你在众多简历中脱颖而出。\n\n有的时候你可能以为自己很优秀，八股文背得贼 6、面试过程也很顺利。但为什么最终没有拿到 offer 呢？可能就是因为你的竞争者的能力上限比你高。\n\n大厂面试除了考察八股文、几道算法题目和项目经历外，一般还会有业务场景设计问题、甚至是行业问题。\n\n举几个例子，都是我当年被问到的：\n\n1. 腾讯实习：如何设计短链系统？\n2. 字节实习：如何设计一个实时弹幕系统？\n3. 字节校招：如何设计地铁轨道调通系统？\n\n\n\n此外，大厂招人会更谨慎。尤其对校招来说，因为能力很强的人很多，宁可漏掉一个人才也不希望错招，不然搞不好就出个删库跑路的招聘事故。所以大厂招聘流程中，可能还会让你做性格测试、综合素质测评，并且会进行严格的背调。所以投递大厂就千万不要简历造假，被查出来可能会拉进黑名单。\n\n\n\n对社招跳槽来说，有一个很大的加分技巧，就是去投递和你之前的工作经历业务相似的公司。因为你之前有这方面的经验，很多术语或者很多业务特定的知识你基本都是理解的。这样相比于其他没有做过此类业务的同学来讲，你的竞争力会更大，找工作也会更轻松一些。\n\n此外，如果实在没办法一步跳槽到中大厂，那就持续跳槽、不断涨薪，一级级往上走就好了。来日方长，我们需要不断学习，持续成长。\n\n建议大家完整观看下我分享的几个工作中提升的方法： https://b23.tv/6BwjNz5\n",
      "category": "文章",
      "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/egPoUK9o-640 (8).jpeg",
      "language": null,
      "viewNum": 31,
      "thumbNum": 3,
      "favourNum": 0,
      "commentNum": 0,
      "priority": 0,
      "userId": "1601072287388278786",
      "reviewStatus": 1,
      "reviewMessage": null,
      "reviewerId": null,
      "reviewTime": null,
      "createTime": "2024-01-10T11:58:04.000+00:00",
      "updateTime": "2024-01-13T09:36:52.000+00:00",
      "user": {
        "id": "1601072287388278786",
        "planetCode": "1",
        "userName": "程序员鱼皮",
        "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
        "gender": 1,
        "userProfile": "这个网站的老大",
        "userRole": "admin",
        "interests": [
          "C++",
          "Java",
          "Python",
          "算法"
        ],
        "place": "上海",
        "birthday": "1998-11-03",
        "school": "东华大学",
        "major": "网络工程",
        "education": null,
        "graduationYear": 2020,
        "jobStatus": null,
        "company": null,
        "job": null,
        "workYear": 2,
        "direction": "后端",
        "goal": null,
        "github": "https://github.com/liyupi",
        "blog": "https://yupi.icu",
        "score": 3020,
        "coin": 170,
        "followeeNum": 1331,
        "followNum": 6,
        "followStatus": null,
        "vipExpireTime": "2286-11-20T17:46:39.000+00:00",
        "lastLoginTime": null,
        "createTime": "2022-12-09T04:32:33.000+00:00",
        "updateTime": "2024-01-12T06:15:20.000+00:00"
      },
      "tags": [
        "文章"
      ],
      "fileList": null,
      "videoList": null,
      "atUserList": null,
      "pictureList": null,
      "hasThumb": false,
      "hasFavour": false,
      "needVip": null,
      "atUserVOList": null
    },
    {
      "id": "1744041756367790081",
      "title": "markdown文本解析成html，并生成大纲",
      "description": "markdown文本解析成html，并生成大纲",
      "content": "markdown转换成html参考：[https://blog.csdn.net/weixin_45894305/article/details/106362783?spm=1001.2014.3001.5506](https://blog.csdn.net/weixin_45894305/article/details/106362783?spm=1001.2014.3001.5506)\n\n### 渲染后样式跟预期不符\n添加css即可，一般直接在父标签上设定一个类名然后给子标签加样式：\n可以在github上找一个用：[https://github.com/sindresorhus/github-markdown-css](https://github.com/sindresorhus/github-markdown-css)\n\n### 转换成html无法通过js操作\n这是因为转换后dom加载需要一定的时间，在这个时间内操作会出现 null 问题，解决：\n```go\nsetTimeout(() => {\n      //要处理转换html后的逻辑\n  },1)\n```\n一般参数1毫秒即可，最好设大一点\n\n### 生成大纲\n#### 拿到所有子标签\n当dom渲染上去后，我们去获取到用于渲染html文本的标签的所有子标签\n```go\ndocument.querySelector(\".markdown-body\").children\n```\n#### 通过正则表达式提取出h1-h10之间的标签\n```go\nconst regex =  /h(10|[1-9])/g;\n      for (let i = 0; i < document.querySelector(\".markdown-body\").children.length; i++){\n        if (htmlContent[i].localName.match(regex)) {\n            \n        }\n}\n```\n#### 处理每个标题\n大纲一般都有父子关系，我们需要去对每个标题进行父子关系的处理，比如标题 3 在标题 1 的后面，那他就是标题 1 的子标题\n```go\nconst  treeData = ref([]);\n//是否找到子目录\nlet isFind = false;\n//解析子目录\nconst setSubDirectory = (directory, level, label) => {\n  //表示当前的目录层级\n  const curr = directory\n  //表示递归的目录层级\n  const children = directory.children\n  if (children.length > 0) {\n    //递归子目录，从最后一个孩子开始\n    setSubDirectory(directory.children[children.length-1],level,label)\n  }\n  //子目录已经归位\n  if (isFind === true) return;\n  //当前层级小于等于目录层级，表示找到了目录\n  if (curr.level < level) {\n    isFind = true\n    curr.children.push({ level, label,children: []})\n  }\n}\n\n//解析html，生成目录树\nconst setTreeDataByHtml = (htmlContent) => {\n  const regex =  /h(10|[1-9])/g;\n      for (let i = 0; i < htmlContent.length; i++){\n        if (htmlContent[i].localName.match(regex)) {\n          const level = parseInt(htmlContent[i].localName.replace(\"h\", \"\"))\n          const label = htmlContent[i].innerText\n          //不需要找子目录\n          if (treeData.value.length === 0 || treeData.value[treeData.value.length - 1].level >= level) {\n              treeData.value.push({ label, level,children: []})\n          } else {\n            isFind = false\n            setSubDirectory(treeData.value[treeData.value.length - 1],level,label)\n          } \n        }\n}\n}\n```\n> 细节：我们将标题分为两类，一种是直接可以用作父标题，一种则是需要添加在父标题中的子标题\n> 如果当前标题的层级小于等于数据中最后一个父标题的层级，那么他就是父标题，直接添加到数组中即可\n> 子标题通过递归的方式，先找到最底层的标题，依次往上寻找，直到找到合适的位置即可\n> 合适的位置：子标题的层级大于父标题的层级，这里我们用level来表示\n\n#### 解析生成大纲\n通过 element-plus 中的 tree组件库来实现\n#### 测试结果\n![image.png](https://cdn.nlark.com/yuque/0/2024/png/38666573/1704479281260-c0c0faf7-ea98-4ca8-a9e7-949882daf848.png#averageHue=%23cddacc&clientId=u26c5aec5-67b1-4&from=paste&height=932&id=u5feaf72a&originHeight=932&originWidth=1877&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1230008&status=done&style=none&taskId=u2c716e12-dc85-4ca8-b7fd-23d955ae337&title=&width=1877)\n#### 完整代码\n> tips:  复制过去记得改，是拿以前项目写的\n\n文章详情页，在此引用大纲页面，为   ArticleTree，调用 ArticleTree 里的函数生成大纲的函数在82行\n```go\n<template>\n  <div class=\"container view\">\n    <div class=\"card\">\n      <div class=\"card-body\">\n        <h3>{{ share.title }}</h3>\n        <span class=\"author_descibe\" style=\"margin-left: 0px\">作者：</span>\n        <router-link class=\"ToOpenShare\" :to=\"{ name: 'home' }\">\n          <img :src=\"share.authorPhoto\" alt=\"\" />\n          <span class=\"author\" style=\"font-size: 18px; margin-left: 10px\"\n            >{{ share.author }}\n          </span>\n        </router-link>\n        <span class=\"createtime\">{{ share.createtime }}</span>\n        <span class=\"reading_descibe\">阅读</span>\n        <span class=\"reading\">{{ share.reading }}</span>\n        <hr />\n\n        <div v-html=\"share.content\" class=\"markdown-body\"></div>\n      </div>\n    </div>\n\n    <hr />\n\n    <CommentView :shareId=\"route.params.shareId\" />\n  </div>\n <ArticleTree ref=\"ArticleTreeRef\"/> \n</template>\n\n<script>\nimport $ from \"jquery\";\nimport { useRoute } from \"vue-router\";\nimport { useStore } from \"vuex\";\nimport { reactive, onMounted,ref } from \"vue\";\nimport CommentView from \"@/views/share/comment/CommentView.vue\";\nimport { marked } from 'marked';\nimport ArticleTree from \"./ArticleTree.vue\";\n\nexport default {\n  components: {\n    CommentView,ArticleTree\n  },\n  setup() {\n    const store = useStore();\n    const route = useRoute();\n    const ArticleTreeRef = ref(null)\n    const share = reactive({\n      title: \"\",\n      createtime: \"\",\n      content: \"\",\n      reading: null,\n      authorPhoto: \"\",\n      author: \"\",\n    });\n    onMounted(() => {\n    const link = document.createElement('link')\n    link.type = 'text/css'\n    link.rel = 'stylesheet'\n    link.href = 'https://cdn.bootcss.com/github-markdown-css/2.10.0/github-markdown.min.css'\n    document.head.appendChild(link)\n});\n\n    \n    //打开某一分享页面就调用\n    const getShare = () => {\n      $.ajax({\n        url: \"https://app5608.acapp.acwing.com.cn/api/get/share/\",\n        type: \"get\",\n        data: {\n          userId: store.state.user.id,\n          shareId: route.params.shareId,\n        },\n        headers: {\n          Authorization: \"Bearer \" + store.state.user.token,\n        },\n\n        success(resp) {\n          // eslint-disable-next-line no-empty\n          if (resp.error_message === \"successfully\") {\n            share.title = resp.share.title;\n            share.createtime = resp.share.createTime;\n            share.content = marked(resp.share.content)\n            setTimeout(() => {\n      ArticleTreeRef.value.setTreeDataByHtml(document.querySelector(\".markdown-body\").children)\n  },1)\n            share.reading = resp.share.reading;\n            share.authorPhoto = resp.authorPhoto;\n            share.author = resp.author;\n          }\n        },\n        error() {},\n      });\n    };\n\n    getShare();\n\n    return {\n      share,\n      route,\n      ArticleTreeRef,\n    };\n  },\n};\n</script>\n\n<style scoped>\n.view {\n  margin-top: 20px;\n}\n\n.container {\n  max-width: 900px;\n}\nhr {\n  color: gray;\n}\nimg {\n  border-radius: 50%;\n  width: 4vh;\n  height: 4vh;\n  margin-left: 10px;\n  line-height: 15px;\n}\n\n.author_descibe,\n.createtime,\n.reading_descibe,\n.reading {\n  font-size: 12px;\n  color: gray;\n  margin-left: 10px;\n}\n\n.ToOpenShare {\n  color: rgb(51, 122, 199);\n  text-decoration: none;\n  line-height: 30px;\n  font-size: 16px;\n}\n\n.ToOpenShare:hover {\n  color: rgb(35, 82, 124);\n  text-decoration: underline;\n}\n</style>\n\n```\nArticleTree\n```go\n<!-- 将文章目录以树的形式展示 -->\n<template>\n  <el-tree :data=\"treeData\" :expand-on-click-node=\"false\" class=\"tree\"></el-tree>\n</template>\n\n<script setup>\nimport { ref,defineExpose } from \"vue\";\nconst  treeData = ref([]);\n//是否找到子目录\nlet isFind = false;\n//解析子目录\nconst setSubDirectory = (directory, level, label) => {\n  //表示当前的目录层级\n  const curr = directory\n  //表示递归的目录层级\n  const children = directory.children\n  if (children.length > 0) {\n    //递归子目录，同层级下，数组下标在其范围即可\n    setSubDirectory(directory.children[children.length-1],level,label)\n  }\n  //子目录已经归位\n  if (isFind === true) return;\n  //当前层级小于等于目录层级，表示找到了目录\n  if (curr.level < level) {\n    isFind = true\n    curr.children.push({ level, label,children: []})\n  }\n}\n\n//解析html，生成目录树\nconst setTreeDataByHtml = (htmlContent) => {\n  const regex =  /h(10|[1-9])/g;\n      for (let i = 0; i < htmlContent.length; i++){\n        if (htmlContent[i].localName.match(regex)) {\n          const level = parseInt(htmlContent[i].localName.replace(\"h\", \"\"))\n          const label = htmlContent[i].innerText\n          //不需要找子目录\n          if (treeData.value.length === 0 || treeData.value[treeData.value.length - 1].level >= level) {\n              treeData.value.push({ label, level,children: []})\n          } else {\n            isFind = false\n            setSubDirectory(treeData.value[treeData.value.length - 1],level,label)\n          } \n        }\n}\n}\ndefineExpose({\n  setTreeDataByHtml\n})\n</script>\n\n\n<style scoped>\n.tree{\n  width: 20%;\n  position: fixed;\n  top: 80px;  /* 从页面顶部的距离 */\n  right: 50px; /* 从页面左侧的距离 */\n}\n</style>\n```\n### 点击目录导航到对应标题位置\n只要获取到dom实例，通过scrollIntoView函数即可完成\n示例：\n```go\nelement.scrollIntoView({\n          behavior: \"instant\",\n          block: \"center\",\n        });\n```\n### 当滚动条滚动到标题位置，设置目录里标题高亮\n通过IntersectionObserver实例来做，当监听的dom出现在视图区域中，会触发回调函数，从而来设置高亮\n示例：\n```go\n// 创建 Intersection Observer 实例\nconst observer = new IntersectionObserver((entries) => {\n  entries.forEach((entry) => {\n    if (entry.isIntersecting) {\n      // 目标元素进入可视区域\n      treeRef.value.setCurrentKey(entry.target.id)\n    }\n  });\n}, { threshold: 0 });\n//将要监听的目标元素加入Observer中\nobserver.observe(htmlContent[i])\n```\n> htmlContent[i] 代表你要监听目标元素的dom\n\n",
      "category": "文章",
      "cover": null,
      "language": null,
      "viewNum": 17,
      "thumbNum": 0,
      "favourNum": 0,
      "commentNum": 0,
      "priority": 0,
      "userId": "1688498276585766913",
      "reviewStatus": 1,
      "reviewMessage": null,
      "reviewerId": null,
      "reviewTime": null,
      "createTime": "2024-01-07T17:02:12.000+00:00",
      "updateTime": "2024-01-09T09:20:53.000+00:00",
      "user": {
        "id": "1688498276585766913",
        "planetCode": "30885",
        "userName": "晨",
        "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/hgPeicCHWgWQlJLO4qOtfOU7rzH6bnWMpiaspouH5u0k6EWhTibmcH2iaJiaLIMhn2bKibvKXSu4QUtI4yJia08ccNwUA/132",
        "gender": null,
        "userProfile": null,
        "userRole": "vip",
        "interests": null,
        "place": null,
        "birthday": null,
        "school": null,
        "major": null,
        "education": null,
        "graduationYear": null,
        "jobStatus": null,
        "company": null,
        "job": null,
        "workYear": null,
        "direction": null,
        "goal": null,
        "github": null,
        "blog": null,
        "score": 0,
        "coin": 0,
        "followeeNum": 0,
        "followNum": 0,
        "followStatus": null,
        "vipExpireTime": "2024-12-30T05:42:47.000+00:00",
        "lastLoginTime": null,
        "createTime": "2023-08-07T10:32:14.000+00:00",
        "updateTime": "2024-01-02T17:07:38.000+00:00"
      },
      "tags": [
        "文章"
      ],
      "fileList": null,
      "videoList": null,
      "atUserList": null,
      "pictureList": null,
      "hasThumb": false,
      "hasFavour": false,
      "needVip": null,
      "atUserVOList": null
    },
    {
      "id": "1743221858255249409",
      "title": "时代变了，Spring 官方抛弃了 Java 8！",
      "description": null,
      "content": "先容许我吐槽一句：Spring 官方，窝草尼玛！\n\n原谅我很愤怒！最近编程导航星球和群友们反复问一个问题：为啥用 IDEA 创建 Spring Boot 项目时，不能选择 Java 8 了？\n\n我本来以为是 IDEA 版本更新导致的 Bug，开始还没在意。\n\n直到我今天自己初始化项目时才发现：卧槽，Java 8 真没了？！ \n\n具体一点，应该是使用 IDEA 内置的 Spring Initializr 创建 Spring Boot 新项目时，没有 Java 8 的选项了，只剩下了 >= 17 的版本：\n\n![](https://pic.yupi.icu/1/image-20231128190051120.png)\n\n去网上搜了一圈，原来这是因为 Spring Boot 官方不再支持 Spring Boot 的 2.x 版本了，之后全力维护 3.x；而 Spring Boot 3.x 对 JDK 版本的最低要求是 17！\n\n![](https://pic.yupi.icu/1/image-20231128190129621.png)\n\n所以 Spring 官方的项目初始化工具自然不再支持 Java 8 了，用网页版也是一样的：\n\n![](https://pic.yupi.icu/1/image-20231128190940856.png)\n\n鱼皮，你不是喜欢用 Java 8 么？不是说学 Java 时除了 Java 8 别用其他的版本么？\n\n这下好了，官方逼着你升级，不给你稳定的机会！\n\n![](https://pic.yupi.icu/1/image-20231128191050766.png)\n\n不过想让我屈服还真没那么容易（毕竟以前所有的项目几乎都是 Java 8，撑死用个 Java 11），我也找到了应对之策。\n\n那就是不要用官方提供的 Spring Initializr 来初始化项目了，我们可以使用阿里云提供的脚手架镜像（https://start.aliyun.com/），一样愉快地使用 Java 8~\n\n在 IDEA 里更改 Server URL 即可：\n\n![](https://pic.yupi.icu/1/image-20231128190138991.png)\n\n\n\n---\n\n\n\n对于这件事，你怎么看？你还会继续使用 Java 8 和 Spring Boot 2.x 么？还是去拥抱新时代的技术呢？",
      "category": "文章",
      "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/bdfkEwIF-640 (7).jpeg",
      "language": null,
      "viewNum": 72,
      "thumbNum": 6,
      "favourNum": 0,
      "commentNum": 0,
      "priority": 0,
      "userId": "1601072287388278786",
      "reviewStatus": 1,
      "reviewMessage": null,
      "reviewerId": null,
      "reviewTime": null,
      "createTime": "2024-01-05T10:44:13.000+00:00",
      "updateTime": "2024-01-12T15:48:26.000+00:00",
      "user": {
        "id": "1601072287388278786",
        "planetCode": "1",
        "userName": "程序员鱼皮",
        "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
        "gender": 1,
        "userProfile": "这个网站的老大",
        "userRole": "admin",
        "interests": [
          "C++",
          "Java",
          "Python",
          "算法"
        ],
        "place": "上海",
        "birthday": "1998-11-03",
        "school": "东华大学",
        "major": "网络工程",
        "education": null,
        "graduationYear": 2020,
        "jobStatus": null,
        "company": null,
        "job": null,
        "workYear": 2,
        "direction": "后端",
        "goal": null,
        "github": "https://github.com/liyupi",
        "blog": "https://yupi.icu",
        "score": 3020,
        "coin": 170,
        "followeeNum": 1331,
        "followNum": 6,
        "followStatus": null,
        "vipExpireTime": "2286-11-20T17:46:39.000+00:00",
        "lastLoginTime": null,
        "createTime": "2022-12-09T04:32:33.000+00:00",
        "updateTime": "2024-01-12T06:15:20.000+00:00"
      },
      "tags": [
        "文章"
      ],
      "fileList": null,
      "videoList": null,
      "atUserList": null,
      "pictureList": null,
      "hasThumb": true,
      "hasFavour": false,
      "needVip": null,
      "atUserVOList": null
    },
    {
      "id": "1742864174209335298",
      "title": "为什么我不建议大学生接公司单？",
      "description": null,
      "content": "大家好，我是鱼皮。前两天，我 [编程导航](https://mp.weixin.qq.com/s/WFz9Yznw-0keNC1dbK6oKg) 的鱼友提了个问：大学生怎么接公司的单赚点零花钱？\n\n然后我很认真地评论了一句：我不建议大学生接公司单。\n\n这位小伙伴很认真，又通过微信单独问我：\n\n![](https://pic.yupi.icu/1/image-20231202144641913.png)\n\n想了想，这应该也是很多大学生都关注的问题，就专门写篇文章来分享下吧。\n\n注意，以下内容不仅适用于大学生，还适用于所有 **没有独立负责开发过完整项目** 的同学。\n\n主要是有几个原因吧：\n\n\n\n### 1、风险 >= 收益\n\n接公司的单，风险一般是大于收益的。\n\n为什么这么说？\n\n既然是接公司的单，一般都是要走正规合同的。而你作为一个未经社会、缺少法律合同意识的大学生，要跟一家公司打交道，用腚想想也知道自己是处于一个相对弱势的地位的，也就是 “乙方”。但凡合同上有个细节你没有注意到，公司说不定都会利用你的 “无知” 来搞你，比如变着花样给你加需求、让你打杂、甚至靠这个赚违约金。\n\n虽然风险大不是绝对和必然的，但是相对于公司给你的那些收益，咱还真没必要去冒这个风险。\n\n\n\n### 2、缺乏掌控力\n\n大学生由于专业知识和实践能力有限，面对一些公司项目时，很有可能难以应对。这里的 “难以应对” 倒不是说你无法完成项目，而是指你缺乏对于项目的 **掌控力** 和 **判断** 。\n\n先说说掌控力。举个例子，比如公司要求一个月完成项目，你如果没有对项目开发流程和需求有足够的了解、没有实际的工作经验，你怎么保证自己在一个月内能够准时交付呢？但凡有一个细节没有考虑到，都可能导致项目的延期，从而给你带来很大的压力。\n\n根据我的观察，很多大学生都容易盲目自信，这份自信源于缺乏经验，自以为跟着教程做出来 2 个项目、会个开发框架就能去接公司的单了？校园教学项目和企业实际项目的差别可是巨大的，需要满足更多的因素，比如时间要求、需求变更、验收标准、项目稳定性等。很多同学连自己的问题、需求都描述不清楚，又怎么能掌控一个公司的项目呢？\n\n\n\n### 3、缺乏判断力\n\n再说说判断力。举个例子，对于毫无接单和工作经验的大学生来说，面对一个项目需求，你知道这个单子大概值多少钱么？要的多了别人觉得你无知，要的少了就相当于亏本给别人打工。而由于接单的价格本身就是灵活的，根据需求复杂度和要求决定，没有统一的标准，所以你也很难找到相关的市场价格来参考。\n\n当然对于这种情况，也有解决方法，那就是可以给自己 “标价”。想想这个项目会花费你多少时间，再给自己定一个时薪，算出来单子的总价。\n\n但是各位大学生朋友们，试问你们现在这个阶段，怎么给自己 “标价” 呢？大学的时期可是非常宝贵的，提升自己是无价的。\n\n\n\n### 4、学业压力\n\n大学生不像是公司的员工，每天的时间都能稳定 —— 就是待在公司工作。像日常的课程、考试、学校活动都会占用你的时间，导致无法专注于这个项目，从而增加项目延期的风险；再或者你投入了过多时间在项目上，也会影响你的学业和技术学习。\n\n这点我是深有感触，大三那段时间，作为学校网站建设工作室的负责人，我经常往另一个校区跑，去跟老师对接项目需求，来回起码三四个小时，身心俱疲。\n\n\n\n### 5、职业发展\n\n前面也提到了，大学时光是非常宝贵的，大多数同学也就三四年的时间，过了这几年就是社会人，想学习和提升自己可就更难咯！\n\n所以我建议大家尽早确认自己的目标，明确自己大学的计划，除非生活所迫，否则尽量不要做和提升自己无关的事情，比如为了十几块钱去跑腿打杂。\n\n接公司单也是同理，如果你自己的能力和项目经验非常丰富，接单除了金钱收益外，也确实能进一步提升自己的能力，那么也可以接。不过我会更建议大家多做自己的项目、多做开源项目、多跟同学组队参加竞赛、参与老师的实验室项目、或者找正式实习，同样可以增加经验。即使真的想接单，也尽量不要去接公司的单，而是可以帮同学做做程序啥的，选择一种风险更低的方式。\n\n\n\n---\n\n\n\n以上，仅为个人观点，希望大学的朋友们能听进去，作为一个参考吧。大家疯四愉快~\n",
      "category": "文章",
      "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/mVx8LAkl-640 (6).jpeg",
      "language": null,
      "viewNum": 31,
      "thumbNum": 0,
      "favourNum": 0,
      "commentNum": 0,
      "priority": 0,
      "userId": "1601072287388278786",
      "reviewStatus": 1,
      "reviewMessage": null,
      "reviewerId": null,
      "reviewTime": null,
      "createTime": "2024-01-04T11:02:54.000+00:00",
      "updateTime": "2024-01-12T18:30:41.000+00:00",
      "user": {
        "id": "1601072287388278786",
        "planetCode": "1",
        "userName": "程序员鱼皮",
        "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
        "gender": 1,
        "userProfile": "这个网站的老大",
        "userRole": "admin",
        "interests": [
          "C++",
          "Java",
          "Python",
          "算法"
        ],
        "place": "上海",
        "birthday": "1998-11-03",
        "school": "东华大学",
        "major": "网络工程",
        "education": null,
        "graduationYear": 2020,
        "jobStatus": null,
        "company": null,
        "job": null,
        "workYear": 2,
        "direction": "后端",
        "goal": null,
        "github": "https://github.com/liyupi",
        "blog": "https://yupi.icu",
        "score": 3020,
        "coin": 170,
        "followeeNum": 1331,
        "followNum": 6,
        "followStatus": null,
        "vipExpireTime": "2286-11-20T17:46:39.000+00:00",
        "lastLoginTime": null,
        "createTime": "2022-12-09T04:32:33.000+00:00",
        "updateTime": "2024-01-12T06:15:20.000+00:00"
      },
      "tags": [
        "文章"
      ],
      "fileList": null,
      "videoList": null,
      "atUserList": null,
      "pictureList": null,
      "hasThumb": false,
      "hasFavour": false,
      "needVip": null,
      "atUserVOList": null
    }
  ],
  "total": "349",
  "size": "8",
  "current": "1",
  "orders": [],
  "optimizeCountSql": true,
  "searchCount": true,
  "countId": null,
  "maxLimit": null,
  "pages": "44"
}